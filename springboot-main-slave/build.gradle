/*
 * This file was generated by the Gradle 'init' task.
 *
 * This is a general purpose Gradle build.
 * Learn more about Gradle by exploring our samples at https://docs.gradle.org/6.8-rc-1/samples
 */
buildscript {
    repositories {
        mavenLocal()
        maven { url "http://maven.aliyun.com/nexus/content/groups/public/" }
        maven { url "https://oss.sonatype.org/content/groups/public/" }
        maven { url "https://repo.spring.io/libs-milestone/" }
        mavenCentral()
        jcenter()
    }
    dependencies {
        classpath ('org.springframework.boot:spring-boot-gradle-plugin:2.1.1.RELEASE')
        // coveralls
        // classpath 'org.kt3k.gradle.plugin:coveralls-gradle-plugin:2.8.2'
    }
}

plugins {
    id 'java'
}

apply plugin: 'org.springframework.boot'
apply plugin: 'io.spring.dependency-management'
apply plugin: 'jacoco'

group 'com.sbe'
version '1.0-SNAPSHOT'

sourceCompatibility = 1.8

repositories {
    mavenLocal()
    maven { url "http://maven.aliyun.com/nexus/content/groups/public/" }
    maven { url "https://oss.sonatype.org/content/groups/public/" }
    maven { url "https://repo.spring.io/libs-milestone/" }
    mavenCentral()
    jcenter()
}

dependencies {
    compile group: 'org.springframework.boot', name: 'spring-boot-starter-web'
    compile group: 'mysql', name: 'mysql-connector-java'
    compile group: 'org.mybatis.spring.boot', name: 'mybatis-spring-boot-starter', version: '2.1.2'

    // 添加依赖shardingsphere
    compile group: 'org.apache.shardingsphere', name: 'sharding-jdbc-spring-boot-starter', version: '4.0.0-RC1'
    compile group: 'org.apache.shardingsphere', name: 'sharding-jdbc-spring-namespace', version: '4.0.0-RC1'

    // druid
//    compile group: 'com.alibaba', name: 'druid-spring-boot-starter', version: '1.1.9'

    testCompile group: 'junit', name: 'junit', version: '4.12'

    testCompile('org.springframework.boot:spring-boot-starter-test') {
        exclude group: 'org.junit.vintage', module: 'junit-vintage-engine'
    }
}

test {
    useJUnitPlatform()
}

jacocoTestReport {
    reports {
        xml.enabled = true // coveralls plugin depends on xml format report
        html.enabled = true
    }
}
check.dependsOn jacocoTestReport

// coveralls {
//     jacocoReportPath 'build/reports/jacoco/jacocoTestReport/jacocoTestReport.xml'
// }

task codeCoverageReport(type: JacocoReport) {
    executionData fileTree(project.rootDir.absolutePath).include("**/build/jacoco/*.exec")

    subprojects.each {
        sourceSets it.sourceSets.main
    }

    reports {
        xml.enabled true
        xml.destination file("${buildDir}/reports/jacoco/report.xml")
        html.enabled false
        csv.enabled false
    }
}

codeCoverageReport.dependsOn {
    subprojects*.test
}

// // A resolvable configuration to collect source code
// def sourcesPath = configurations.create("sourcesPath") {
//     visible = false
//     canBeResolved = true
//     canBeConsumed = false
//     extendsFrom(configurations.implementation)
//     attributes {
//         attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, Usage.JAVA_RUNTIME))
//         attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.DOCUMENTATION))
//         attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, 'source-folders'))
//     }
// }

// // A resolvable configuration to collect JaCoCo coverage data
// def coverageDataPath = configurations.create("coverageDataPath") {
//     visible = false
//     canBeResolved = true
//     canBeConsumed = false
//     extendsFrom(configurations.implementation)
//     attributes {
//         attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, Usage.JAVA_RUNTIME))
//         attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.DOCUMENTATION))
//         attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, 'jacoco-coverage-data'))
//     }
// }

// // Task to gather code coverage from multiple subprojects
// def codeCoverageReport = tasks.register('codeCoverageReport', JacocoReport) {
//     additionalClassDirs(configurations.runtimeClasspath)
//     additionalSourceDirs(sourcesPath.incoming.artifactView { lenient(true) }.files)
//     executionData(coverageDataPath.incoming.artifactView { lenient(true) }.files.filter { it.exists() })

//     reports {
//         // xml is usually used to integrate code coverage with
//         // other tools like SonarQube, Coveralls or Codecov
//         xml.enabled true

//         // HTML reports can be used to see code coverage
//         // without any external tools
//         html.enabled true
//     }
// }

// // Make JaCoCo report generation part of the 'check' lifecycle phase
// tasks.named("check") {
//     dependsOn(codeCoverageReport)
// }